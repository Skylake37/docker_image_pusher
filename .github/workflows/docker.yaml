name: Docker Image Sync to Aliyun

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'images.txt'

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"
  WEBHOOK_URL: "${{ secrets.WEBHOOK_URL }}" # 在 Secrets 中配置飞书或企微地址

jobs:
  build:
    name: Sync Images
    runs-on: ubuntu-latest
    steps:
      - name: Maximize build space
        uses: easimon/maximize-build-space@master
        with:
          root-reserve-mb: 2048
          swap-size-mb: 128
          remove-dotnet: 'true'
          remove-haskell: 'true'
          overprovision-lvm: 'true'
          build-mount-path: '/var/lib/docker/'
    
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Restart docker
        run: |
          # 清理 Docker 构建缓存（如果之前没做）
          docker builder prune -f
          # 清理 Runner 日志（不影响运行中的任务）
          sudo rm -rf /home/runner/actions-runner/_diag/*
          sudo service docker restart
        
      - name: Sync and Push to Aliyun
        id: sync_step
        run: |
          echo "$ALIYUN_REGISTRY_PASSWORD" | docker login -u "$ALIYUN_REGISTRY_USER" --password-stdin "$ALIYUN_REGISTRY"
          
          SYNC_SUMMARY=""
          SUCCESS_COUNT=0
          FAILURE_COUNT=0
          
          while IFS= read -r line || [ -n "$line" ]; do
              [[ -z "$line" ]] || [[ "$line" =~ ^\s*# ]] && continue
          
              # 解析行：第一个字段为镜像名，其余为参数
              eval "parts=($line)"
              full_image="${parts[0]}"
              pull_params=("${parts[@]:1}")
          
              # ---------- 提取镜像名标签和仓库组织（原逻辑不变） ----------
              image_name_tag=$(echo "$full_image" | awk -F'/' '{print $NF}')
              if [[ "$full_image" == *"/"* ]]; then
                  org_part=$(echo "$full_image" | sed "s|\/${image_name_tag}||" | tr '/' '_')
                  new_repo_name="${org_part}/${image_name_tag}"
              else
                  # org_part="library"
                  new_repo_name="${image_name_tag}"
              fi
              # new_repo_name="${org_part}_${image_name_tag}"
              target_image="$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$new_repo_name"

              echo "Processing: $full_image → $target_image"
              
              # 获取源镜像 digest（需要 jq 解析 JSON）
              if ! src_digest=$(skopeo inspect docker://"$full_image" 2>/dev/null | jq -r '.Digest'); then
                  echo "❌ Failed to inspect source image: $full_image"
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n🚨 ${image_name_tag} (获取源信息失败)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
                  continue
              fi
      
              # 检查目标镜像是否存在并获取 digest
              dest_exists=false
              if dest_info=$(skopeo inspect docker://"$target_image" --creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" 2>/dev/null); then
                  dest_digest=$(echo "$dest_info" | jq -r '.Digest')
                  dest_exists=true
              fi
      
              # 如果目标存在且 digest 相同，跳过
              if $dest_exists && [ "$src_digest" = "$dest_digest" ]; then
                  echo "✅ Image $image_name_tag already up-to-date, skipping"
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n✨ ${image_name_tag} (已同步)"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                  continue
              fi
      
              # 准备 skopeo copy 参数
              skopeo_args=()
              # 解析平台参数（如果有）
              for ((i=0; i<${#pull_params[@]}; i++)); do
                  if [[ "${pull_params[i]}" == "--platform" ]] && [[ $((i+1)) -lt ${#pull_params[@]} ]]; then
                      platform="${pull_params[i+1]}"
                      os=$(echo "$platform" | cut -d/ -f1)
                      arch=$(echo "$platform" | cut -d/ -f2)
                      skopeo_args+=(--override-os "$os" --override-arch "$arch")
                      echo "🔧 Using platform: $platform"
                      break
                  fi
              done
      
              # 执行复制
              echo "🔄 Copying $full_image to $target_image ..."
              if skopeo copy "${skopeo_args[@]}" \
                  --dest-creds "$ALIYUN_REGISTRY_USER:$ALIYUN_REGISTRY_PASSWORD" \
                  docker://"$full_image" \
                  docker://"$target_image"; then
                  echo "✅ Success: $image_name_tag"
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n✨ ${image_name_tag}"
                  SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
              else
                  echo "❌ Failed: $image_name_tag"
                  SYNC_SUMMARY="${SYNC_SUMMARY}\n🚨 ${image_name_tag} (复制失败)"
                  FAILURE_COUNT=$((FAILURE_COUNT + 1))
              fi
          done < images.txt

          # 写入环境变量
          echo "SUCCESS_COUNT=$SUCCESS_COUNT" >> $GITHUB_ENV
          echo "FAILURE_COUNT=$FAILURE_COUNT" >> $GITHUB_ENV
          {
            echo 'SYNC_RESULT<<EOF'
            echo -e "$SYNC_SUMMARY"
            echo 'EOF'
          } >> $GITHUB_ENV

      - name: 发送 Webhook 通知
        if: always()
        run: |
          if [ -z "${{ secrets.WEBHOOK_URL }}" ]; then exit 0; fi

          S_COUNT=${{ env.SUCCESS_COUNT }}
          F_COUNT=${{ env.FAILURE_COUNT }}

          # 1. 判定标题和主状态
          if [ "$F_COUNT" -gt 0 ]; then
              TITLE="❌ 阿里云镜像同步失败"
              CONTENT="⚠️ 警告：有 $F_COUNT 个镜像同步出现异常，请及时检查。"
          elif [ "$S_COUNT" -gt 0 ]; then
              TITLE="✅ 阿里云镜像同步成功"
              CONTENT="本次新增同步镜像如下："
          else
            # 如果全是跳过，为了不骚扰，可以选择不发，或者发一条简洁的
            TITLE="☕ 同步任务完成 (无新镜像)"
            CONTENT="检测到 images.txt 中暂无新镜像需要同步。"
          fi

          # 2. 组装最终文本 (移除跳过的列表，只显示 SYNC_RESULT)
          RAW_TEXT=$(cat <<EOF
          $TITLE
          ━━━━━━━━━━━━━━━━
          $CONTENT
          ${{ env.SYNC_RESULT }}

          📊 统计: 成功 $S_COUNT | 失败 $F_COUNT
          🔗 详情: [查看 GitHub Action 日志](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
          EOF
          )

          # 3. 发送
          JSON_PAYLOAD=$(jq -n --arg msg "$RAW_TEXT" '{"msg_type":"text","content":{"text":$msg}}')
          curl -X POST -H "Content-Type: application/json" -d "$JSON_PAYLOAD" "${{ secrets.WEBHOOK_URL }}"
